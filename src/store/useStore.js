import { create } from 'zustand';
import { mockProfile } from '@/data/mockProfile';
import { mockJobs, poorMatchJobs } from '@/data/mockJobs';

export const useStore = create((set, get) => ({
  // Theme
  darkMode: false,
  toggleDarkMode: () => set((state) => ({ darkMode: !state.darkMode })),

  // User Profile
  profile: { ...mockProfile },
  updateProfile: (updates) => set((state) => ({
    profile: { ...state.profile, ...updates }
  })),
  
  // Update profile completion status
  updateCompletionStatus: (section, isComplete) => set((state) => ({
    profile: {
      ...state.profile,
      completionStatus: {
        ...state.profile.completionStatus,
        [section]: isComplete
      }
    }
  })),

  // Check if profile is complete
  isProfileComplete: () => {
    const { profile } = get();
    const { completionStatus } = profile;
    return completionStatus.resume && 
           completionStatus.basicInfo && 
           completionStatus.skills && 
           completionStatus.quiz;
  },

  // Jobs
  availableJobs: [...mockJobs],
  currentJobIndex: 0,
  appliedJobs: [],
  skippedJobs: [],

  // Recalculate jobs based on profile completeness
  recalculateJobs: () => {
    const isComplete = get().isProfileComplete();
    set({
      availableJobs: isComplete ? [...mockJobs] : [...poorMatchJobs],
      currentJobIndex: 0
    });
  },

  // Get current job
  getCurrentJob: () => {
    const { availableJobs, currentJobIndex, appliedJobs, skippedJobs } = get();
    const processedJobIds = [...appliedJobs, ...skippedJobs].map(j => j.id);
    
    // Filter out already processed jobs
    const unprocessedJobs = availableJobs.filter(
      job => !processedJobIds.includes(job.id)
    );
    
    if (currentJobIndex >= unprocessedJobs.length) {
      return null;
    }
    
    return unprocessedJobs[currentJobIndex];
  },

  // Apply to job
  applyToJob: (job) => {
    set((state) => ({
      appliedJobs: [...state.appliedJobs, { 
        ...job, 
        status: 'Applied',
        appliedDate: new Date().toISOString(),
        autoGeneratedResume: true
      }],
      currentJobIndex: state.currentJobIndex + 1
    }));
  },

  // Skip job
  skipJob: (job) => {
    set((state) => ({
      skippedJobs: [...state.skippedJobs, job],
      currentJobIndex: state.currentJobIndex + 1
    }));
  },

  // Update application status (for mock status changes)
  updateApplicationStatus: (jobId, newStatus) => {
    set((state) => ({
      appliedJobs: state.appliedJobs.map(job =>
        job.id === jobId ? { ...job, status: newStatus } : job
      )
    }));
  },

  // Reset matches (for recalibration)
  resetMatches: () => {
    set({
      currentJobIndex: 0,
      appliedJobs: [],
      skippedJobs: []
    });
  },

  // Skill gap analysis
  getSkillGaps: (job) => {
    const { profile } = get();
    const userSkills = profile.skills || [];
    const requiredSkills = job?.requiredSkills || [];
    
    const gaps = requiredSkills.filter(
      skill => !userSkills.some(
        userSkill => userSkill.toLowerCase() === skill.toLowerCase()
      )
    );
    
    const matched = requiredSkills.filter(
      skill => userSkills.some(
        userSkill => userSkill.toLowerCase() === skill.toLowerCase()
      )
    );
    
    return { gaps, matched, total: requiredSkills.length };
  },

  // Get improvement suggestions
  getImprovementSuggestions: (gaps) => {
    return gaps.map(skill => ({
      skill,
      course: `Complete a ${skill} course`,
      improvement: `+${Math.floor(Math.random() * 10) + 5}%`
    }));
  }
}));
